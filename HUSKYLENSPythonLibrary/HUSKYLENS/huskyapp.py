from huskylib import HuskyLensLibrary
from enum import Enum, auto

import gtts
from playsound import playsound

import threading, time

huskylens = HuskyLensLibrary("SERIAL", "/dev/ttyUSB0")

_global_arrows = []
_global_blocks = []
_current_id = 1

# Declare Modes

class mode(Enum):
	KNOCK = "KNOCK"
	OBJ_RECOGNITION = "YOLO_OBJECT_RECOGNITION"
	FACE_RECOGNITION = "ALGORITHM_FACE_RECOGNITION"
	LINE_TRACKING = "ALGORITHM_LINE_TRACKING"

# control algorithms
def switch_to_face_recognition():
	huskylens.algorthim("ALGORITHM_FACE_RECOGNITION")

def switch_to_line_tracking():
	huskylens.algorthim("ALGORITHM_LINE_TRACKING")

def switch_to_object_recognition():
	huskylens.algorthim("ALGORITHM_OBJECT_RECOGNITION")
	
def switch_to_default():
	switch_to_line_tracking()

# learn and unlearn
def learn():
	global _current_id
	huskylens.learn(_current_id)
	custom_name = input("Type out your custom name for id " + str(_current_id) + " and press enter\n")
	huskylens.setCustomName(custom_name, _current_id)
	_current_id+=1

# Decode the data generated by the HuskyLens.
def decodeHuskyLens(self, obj):
	count=1
	if(type(obj)==list):
		for i in obj:
			#print("\t " + ("BLOCK_" if i.type=="BLOCK" else "ARROW_") + str(count) + " : " + json.dumps(i.__dict__))
			self.husky_lens_ID = json.loads(json.dumps(i.__dict__))["ID"]
			count+=1
	else:
		#print("\t " + ("BLOCK_" if obj.type=="BLOCK" else "ARROW_") + str(count) + " : " + json.dumps(obj.__dict__))
		self.husky_lens_ID = json.loads(json.dumps(obj.__dict__))["ID"]

		# Get the recently read block from the HuskyLens to detect the object ID.
		self.decodeHuskyLens(self.husky_lens.blocks())

def knock():
	print(huskylens.knock())
	playsound("knock.wav")
	time.sleep(5)
	t = threading.Thread(target=knock)
	t.start()
	
def framenumber():
	print("frames processed: " + str(huskylens.frameNumber()))
	time.sleep(5)
	t = threading.Thread(target=framenumber)
	t.start()
	
def count():
	print("count: " + str(huskylens.count()))
	time.sleep(5)
	t = threading.Thread(target=count)
	t.start()

# -- BUGGY- always empty. What is proper input/output?
def process_blocks():
	global_blocks = huskylens.blocks()
	print("blocks:\n" + str(global_blocks))

# -- BUGGY- always empty. What is proper input/output?
def process_arrows():
	global_arrows = huskylens.arrows()
	print("arrows:\n" + str(global_arrows))
	time.sleep(5)
	t = threading.Thread(target=process_arrows)
	t.start()
	
def lens_display(text, X, Y):
	huskylens.customText(text, X, Y)
	time.sleep(10)
	huskylens.clearText()

# Entry point to the program
def main():
	test = gtts.gTTS(text="Knock confirmed", lang='en')
	test.save("knock.wav")
	
	switch_to_object_recognition()
	learn()
	learn()
	
	threads = []
	
	knock_thread = threading.Thread(target=knock)
	threads.append(knock_thread)
	knock_thread.start()
		
	frame_thread = threading.Thread(target=framenumber)
	threads.append(frame_thread)
	frame_thread.start()
	
	count_thread = threading.Thread(target=count)
	threads.append(count_thread)
	count_thread.start()
	
	blocks_thread = threading.Thread(target=process_blocks)
	threads.append(blocks_thread)
	blocks_thread.start()
	
	arrows_thread = threading.Thread(target=process_arrows)
	threads.append(arrows_thread)
	arrows_thread.start()
	
	lens_display_thread = threading.Thread(target=lens_display, args=("Welcome to S.E.E.", 85, 30, ))
	threads.append(lens_display_thread)
	lens_display_thread.start()
	

if __name__ == "__main__":
	main()
