from huskylib import HuskyLensLibrary

import gtts
from playsound import playsound

import threading, time

import json

huskylens = HuskyLensLibrary("SERIAL", "/dev/ttyUSB0")

_global_arrows = []
_global_blocks = []
_face_current_id = 1
_in_memory_map_id_to_name = {}
_current_mode = "ALGORITHM_FACE_RECOGNITION"

def print_blocks(block_array):
	for obj in block_array:
		tostr = ""
		tostr += str(obj.x) + "\n"
		tostr += str(obj.y) + "\n"
		tostr += str(obj.ID)
		print(tostr)

# Control algorithms
def switch_to_face_recognition():
	huskylens.algorthim("ALGORITHM_FACE_RECOGNITION")
	_current_mode = "ALGORITHM_FACE_RECOGNITION"

def switch_to_line_tracking():
	huskylens.algorthim("ALGORITHM_LINE_TRACKING")
	_current_mode = "ALGORITHM_LINE_TRACKING"

def switch_to_object_recognition():
	huskylens.algorthim("ALGORITHM_OBJECT_RECOGNITION")
	_current_mode = "ALGORITHM_OBJECT_RECOGNITION"
	
def switch_to_object_classification():
	huskylens.algorthim("ALGORITHM_OBJECT_CLASSIFICATION")
	_current_mode = "ALGORITHM_OBJECT_CLASSIFICATION"

def switch_to_default():
	switch_to_face_recognition()
	
# learn objects

def learn(name, current_id):
	try:
		result = huskylens.learn(current_id)
		print(result)
	except Exception as e:
		print(e)
		
# learn faces
def learn_faces():
	global _face_current_id
	
	name = input("Type the name and press enter to start learning\n")	
	
	try:
		result = huskylens.learn(_face_current_id)
		_in_memory_map_id_to_name[_face_current_id] = name
		test = gtts.gTTS(text="This person is now recognized as" + str(name), lang='en')
		filename = str(_face_current_id)+".wav"
		test.save(filename)
		print(result)
	except Exception as e:
		print(e)
	
	_face_current_id+=1
	print(_in_memory_map_id_to_name)
	time.sleep(10)
	t = threading.Thread(target=learn_faces)
	t.start()
	
# constantly running method to see if any learned faces are present, if while analyzing for 3 seconds detect the same face for
#iterations, detections, prevID
def detect_faces():
	print(huskylens.count())
	if(_current_mode == "ALGORITHM_FACE_RECOGNITION" and len(_in_memory_map_id_to_name)>0):
		data = huskylens.blocks()

		learned_blocks = huskylens.requestAll()
		for i in learned_blocks:
			ID = i.ID
			filename = str(ID)+".wav"
			try:
				playsound(filename)
				print("Learned knock for " + str(ID))
			except Exception:
				print("Could not find face corresponding to " + str(ID))

	time.sleep(0.5)
	t = threading.Thread(target=detect_faces)
	t.start()

# Decode the data generated by the HuskyLens.
def decodeHuskyLens(obj):
	count=1
	if(type(obj)==list):
		print("List object\n")
		for i in obj:
			print("\t " + ("BLOCK_" if i.type=="BLOCK" else "ARROW_") + str(count) + " : " + json.dumps(i.__dict__))
			self.husky_lens_ID = json.loads(json.dumps(i.__dict__))["ID"]
			count+=1
	else:
		print("Not list object\n")
		print("\t " + ("BLOCK_" if obj.type=="BLOCK" else "ARROW_") + str(count) + " : " + json.dumps(obj.__dict__))
		self.husky_lens_ID = json.loads(json.dumps(obj.__dict__))["ID"]

		# Get the recently read block from the HuskyLens to detect the object ID.
		self.decodeHuskyLens(self.husky_lens.blocks())

def knock():
	print(huskylens.knock())
	playsound("knock.wav")
	time.sleep(5)
	t = threading.Thread(target=knock)
	t.start()
	
def framenumber():
	print("frames processed: " + str(huskylens.frameNumber()))
	time.sleep(5)
	t = threading.Thread(target=framenumber)
	t.start()
	
def count():
	print("count: " + str(huskylens.count()))
	time.sleep(5)
	t = threading.Thread(target=count)
	t.start()

# -- BUGGY- always empty. What is proper input/output?
def process_blocks():
	global_blocks = huskylens.blocks()
	print("blocks:\n" + str(global_blocks))

# -- BUGGY- always empty. What is proper input/output?
def process_arrows():
	global_arrows = huskylens.arrows()
	print("arrows:\n" + str(global_arrows))
	time.sleep(5)
	t = threading.Thread(target=process_arrows)
	t.start()
	
def lens_display(text, X, Y):
	huskylens.customText(text, X, Y)
	time.sleep(10)
	huskylens.clearText()

# Entry point to the program
def main():
	switch_to_face_recognition()
	time.sleep(0.5)

	test = gtts.gTTS(text="Knock confirmed", lang='en')
	test.save("knock.wav")
		
	print(huskylens.learnedObjCount())
	
	print(huskylens.forget())
	time.sleep(0.5)
	
	print(huskylens.learnedObjCount())
	
# Threading for test methods
	threads = []
	
	# ~ knock_thread = threading.Thread(target=knock)
	# ~ threads.append(knock_thread)
	# ~ knock_thread.start()
		
	# ~ frame_thread = threading.Thread(target=framenumber)
	# ~ threads.append(frame_thread)
	# ~ frame_thread.start()
	
	# ~ count_thread = threading.Thread(target=count)
	# ~ threads.append(count_thread)
	# ~ count_thread.start()
	
	# ~ blocks_thread = threading.Thread(target=process_blocks)
	# ~ threads.append(blocks_thread)
	# ~ blocks_thread.start()
	
	# ~ arrows_thread = threading.Thread(target=process_arrows)
	# ~ threads.append(arrows_thread)
	# ~ arrows_thread.start()
	
	# ~ lens_display_thread = threading.Thread(target=lens_display, args=("Welcome to S.E.E.", 85, 30, ))
	# ~ threads.append(lens_display_thread)
	# ~ lens_display_thread.start()
	
# ~ # Face recognition
	
	learn_faces_thread = threading.Thread(target=learn_faces)
	threads.append(learn_faces_thread)
	learn_faces_thread.start()
	
	detect_faces_thread = threading.Thread(target=detect_faces)
	threads.append(detect_faces_thread)
	detect_faces_thread.start()
	
if __name__ == "__main__":
	main()
