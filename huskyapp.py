from huskylib import HuskyLensLibrary

import gtts
from playsound import playsound

import threading, time

import os
import os.path
from glob import glob 

huskylens = HuskyLensLibrary("SERIAL", "/dev/ttyUSB0")

_face_current_id = 1
_in_memory_map_id_to_name = {}

_line_id_to_name = {1:"crosswalk", 2:"sidewalk", 3:"floor"}

_current_mode = "ALGORITHM_FACE_RECOGNITION"

def print_blocks(block_array):
	for obj in block_array:
		tostr = ""
		tostr += str(obj.x) + "\n"
		tostr += str(obj.y) + "\n"
		tostr += str(obj.ID)
		print(tostr)

# Control algorithms
def switch_to_face_recognition():
	huskylens.algorthim("ALGORITHM_FACE_RECOGNITION")
	_current_mode = "ALGORITHM_FACE_RECOGNITION"

def switch_to_line_tracking():
	huskylens.algorthim("ALGORITHM_LINE_TRACKING")
	_current_mode = "ALGORITHM_LINE_TRACKING"

def switch_to_object_recognition():
	huskylens.algorthim("ALGORITHM_OBJECT_RECOGNITION")
	_current_mode = "ALGORITHM_OBJECT_RECOGNITION"
	
def switch_to_object_classification():
	huskylens.algorthim("ALGORITHM_OBJECT_CLASSIFICATION")
	_current_mode = "ALGORITHM_OBJECT_CLASSIFICATION"

def switch_to_default():
	switch_to_face_recognition()

# helper test methods

def knock():
	test = gtts.gTTS(text="Knock confirmed", lang='en')
	test.save("knock.wav")
	print(huskylens.knock())
	playsound("knock.wav")
	time.sleep(5)
	t = threading.Thread(target=knock)
	t.start()
	
def framenumber():
	print("frames processed: " + str(huskylens.frameNumber()))
	time.sleep(5)
	t = threading.Thread(target=framenumber)
	t.start()
	
def count():
	print("count: " + str(huskylens.count()))
	time.sleep(5)
	t = threading.Thread(target=count)
	t.start()
	
def lens_display(text, X, Y):
	huskylens.customText(text, X, Y)
	time.sleep(10)
	huskylens.clearText()
		
# learn faces
def learn_faces():
	global _face_current_id
	
	# ~ person = input("Type the name and press enter to start learning\n")
	name = "person"+str(_face_current_id)
	try:
		result = huskylens.learn(_face_current_id)
		_in_memory_map_id_to_name[_face_current_id] = name
		test = gtts.gTTS(text="This person is now recognized as" + str(name), lang='en')
		filename =  "face_" + str(_face_current_id)+".wav"
		test.save(filename)
		print(result)
	except Exception as e:
		print("failed in learn")
	
	_face_current_id+=1
	print(_in_memory_map_id_to_name)
	time.sleep(10)
	t = threading.Thread(target=learn_faces)
	t.start()
	
# constantly running method to see if any learned faces are present, if while analyzing for 3 seconds detect the same face for
#iterations, detections, prevID
def detect_faces():
	if(_current_mode == "ALGORITHM_FACE_RECOGNITION" and len(_in_memory_map_id_to_name)>0):
		try:
			learned_blocks = huskylens.requestAll()
			for i in learned_blocks:
				ID = i.ID
				filename = "face_" + str(ID)+".wav"
				if(ID > 0):
					try:
						playsound(filename)
						print("Recognized face " + str(ID))
					except Exception:
						print("Could not find face corresponding to " + str(ID))
				else:
					print("Unlearned face detected")
		except Exception:
			print("Failed in request all")
	time.sleep(0.1)
	t = threading.Thread(target=detect_faces)
	t.start()

# Decode the data generated by the HuskyLens.
# ~ def decodeHuskyLens(obj):
	# ~ count=1
	# ~ if(type(obj)==list):
		# ~ print("List object\n")
		# ~ for i in obj:
			# ~ print("\t " + ("BLOCK_" if i.type=="BLOCK" else "ARROW_") + str(count) + " : " + json.dumps(i.__dict__))
			# ~ self.husky_lens_ID = json.loads(json.dumps(i.__dict__))["ID"]
			# ~ count+=1
	# ~ else:
		# ~ print("Not list object\n")
		# ~ print("\t " + ("BLOCK_" if obj.type=="BLOCK" else "ARROW_") + str(count) + " : " + json.dumps(obj.__dict__))
		# ~ self.husky_lens_ID = json.loads(json.dumps(obj.__dict__))["ID"]

		# ~ # Get the recently read block from the HuskyLens to detect the object ID.
		# ~ self.decodeHuskyLens(self.husky_lens.blocks())
		
# learn lines
def learn_lines(curr_id):
	print("Learning")
	try:
		result = huskylens.learn(curr_id)
		filename = "line_" + str(curr_id)+".wav"
		if(not os.path.isfile(filename)):
			test = gtts.gTTS(text="Line tracked as " + str(_line_id_to_name[curr_id]), lang='en')
			test.save(filename)
			print("Saved file " + filename)
		print(result)
	except Exception as e:
		print(e)
	time.sleep(0.01)
	t = threading.Thread(target=learn_lines, args=(1,))
	t.start()
	
# constantly running method to track if any learned lines are present
def line_tracking():
	print("Tracking")
	if(_current_mode == "ALGORITHM_LINE_TRACKING" and len(_line_id_to_name) > 0):
		learned_arrows = huskylens.requestAll()
		for i in learned_arrows:
			ID = i.ID
			filename = "line_" + str(ID)+".wav"
			try:
				playsound(filename)
				print("Tracking line " + _line_id_to_name[ID])
			except Exception:
				print("Could not find line type corresponding to " + str(ID))

	time.sleep(0.1)
	t = threading.Thread(target=line_tracking)
	t.start()

def delete_faces_in_dir():
	for f in glob ('/home/see/EE475Capstone/HUSKYLENSPythonLibrary/HUSKYLENS/*.wav'):
		os.unlink(f)

# Entry point to the program
def main():
	switch_to_face_recognition()
	time.sleep(0.5)
	
	# ~ delete_faces_in_dir()
	print(huskylens.learnedObjCount())
	print(huskylens.forget())
	time.sleep(0.5)
	print(huskylens.learnedObjCount())
	
	switch_to_default()
	
# Threading for test methods
	threads = []
	
	# ~ knock_thread = threading.Thread(target=knock)
	# ~ threads.append(knock_thread)
	# ~ knock_thread.start()
		
	# ~ frame_thread = threading.Thread(target=framenumber)
	# ~ threads.append(frame_thread)
	# ~ frame_thread.start()
	
	# ~ count_thread = threading.Thread(target=count)
	# ~ threads.append(count_thread)
	# ~ count_thread.start()
	
	# ~ lens_display_thread = threading.Thread(target=lens_display, args=("Welcome to S.E.E.", 85, 30, ))
	# ~ threads.append(lens_display_thread)
	# ~ lens_display_thread.start()
	
# Face recognition
	
	learn_faces_thread = threading.Thread(target=learn_faces)
	threads.append(learn_faces_thread)
	learn_faces_thread.start()
	
	detect_faces_thread = threading.Thread(target=detect_faces)
	threads.append(detect_faces_thread)
	detect_faces_thread.start()
	
# Line Tracking

	# ~ learn_lines_thread = threading.Thread(target=learn_lines, args=(1,))
	# ~ threads.append(learn_lines_thread)
	# ~ learn_lines_thread.start()
	
	# ~ line_tracking_thread = threading.Thread(target=line_tracking)
	# ~ threads.append(line_tracking_thread)
	# ~ line_tracking_thread.start()
	
if __name__ == "__main__":
	main()
